package org.kvilarinho.taskmanager;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.kvilarinho.taskmanager.TaskManager.TASK_FILE;

/**
 * Repository responsible for managing task storage and persistence.
 * <p>
 * Maintains all tasks in an in-memory {@link Map} and synchronizes
 * them with a text file defined by {@link TaskManager#TASK_FILE}.
 * Tasks are stored line by line in a human-readable format:
 * </p>
 *
 * <pre>{@code
 * [x] id: 1 - Buy milk
 * [ ] id: 2 - Finish report
 * }</pre>
 *
 * <p><b>Responsibilities:</b></p>
 * <ul>
 *   <li>Load tasks from a persistent file into memory</li>
 *   <li>Provide access to the in-memory task collection</li>
 *   <li>Persist all tasks back to the file when requested</li>
 *   <li>Generate incremental task IDs</li>
 * </ul>
 *
 * <p>
 * This class follows the <b>Singleton</b> pattern to ensure that only
 * one repository instance exists throughout the application lifecycle.
 * </p>
 *
 * @author KÃ¡tia Vilarinho
 * @version 1.1
 * @since 1.0
 */
public class TaskRepository {

    /** The file where all tasks are stored persistently. */
    private final File taskFile;

    /** In-memory storage of all tasks, mapped by their unique ID. */
    private final Map<Integer, Task> tasks;

    /** Singleton instance of the repository. */
    private static TaskRepository INSTANCE;

    /**
     * Creates a new repository, initializing the task file and the in-memory map.
     * <p>
     * This constructor is private to enforce the Singleton design pattern.
     * </p>
     */
    private TaskRepository() {
        this.taskFile = new File(TASK_FILE);
        this.tasks = new HashMap<>();
    }

    /**
     * Loads all tasks from the persistent file into memory.
     * <p>
     * If the file does not exist, it will be created automatically.
     * Each line is expected to follow the format:
     * </p>
     *
     * <pre>{@code
     * [x] id: 1 - Task description
     * }</pre>
     *
     * <p>
     * Lines that do not follow this format are ignored.
     * </p>
     */
    public void loadTasksFromRecord() {
        List<String> lines;

        try {
            if (!taskFile.exists()) {
                taskFile.createNewFile();
            }

            lines = Files.readAllLines(taskFile.toPath(), StandardCharsets.UTF_8);

        } catch (IOException e) {
            System.err.println("Error loading tasks: " + e.getMessage());
            return;
        }

        for (String line : lines) {
            if (line == null || line.isBlank()) {
                continue;
            }

            try {
                // Expected format: [x] id: 1 - description
                int idStart = line.indexOf("id: ") + 4;
                int idEnd = line.indexOf(" -");
                int id = Integer.parseInt(line.substring(idStart, idEnd).trim());

                String description = line.substring(idEnd + 3).trim();
                boolean done = line.startsWith("[x]");

                tasks.put(id, new Task(id, description, done));

            } catch (Exception e) {
                System.err.println("Skipping invalid line: " + line);
            }
        }
    }

    /**
     * Saves all current tasks to the persistent file.
     * <p>
     * Existing file content is replaced with the current task list.
     * Each task is written using its {@link Task#toRecord()} representation.
     * </p>
     *
     * @throws IOException if an I/O error occurs while writing to the file
     */
    public void saveInFile() throws IOException {
        try (BufferedWriter writer = new BufferedWriter(
                new OutputStreamWriter(new FileOutputStream(taskFile, false), StandardCharsets.UTF_8))) {

            for (Task task : tasks.values()) {
                writer.write(task.toRecord());
                writer.newLine();
            }

        } catch (IOException e) {
            System.err.println("Error saving tasks: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Returns the map containing all in-memory tasks.
     *
     * @return the map of tasks indexed by their IDs
     */
    public Map<Integer, Task> getTasks() {
        return tasks;
    }

    /**
     * Returns the next available ID for a new task.
     * <p>
     * The ID is generated by finding the current maximum ID in the map
     * and incrementing it by one.
     * </p>
     *
     * @return the next unique task ID
     */
    public int getNextId() {
        int maxId = tasks.keySet().stream()
                .mapToInt(Integer::intValue)
                .max()
                .orElse(0);

        return maxId + 1;
    }

    /**
     * Returns the singleton instance of the {@code TaskRepository}.
     * <p>
     * If no instance exists, a new one is created.
     * </p>
     *
     * @return the single {@code TaskRepository} instance
     */
    public static TaskRepository getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new TaskRepository();
        }
        return INSTANCE;
    }
}
